
Tutorial for ``Group.py``
=========================

This folder contains an extension of the
`absalg <https://github.com/naftaliharris/Abstract-Algebra>`__ library
by `Naftali Harris <http://www.naftaliharris.com>`__.

We start by loading the library

.. code:: python

    from Group import *

 Defining a group
-----------------

Let us define a group from scratch. We need a set and a binary
operation.

.. code:: python

    S=Set(range(5))
    b_op=Function(S.cartesian(S),S,lambda x: (x[0]+x[1])%5)
    G=Group(S,b_op)

We can, for instance, list the elements in ``G``. Observe that this is
just a representation of them.

.. code:: python

    list(G)




.. parsed-literal::

    [0, 1, 2, 3, 4]



This does not mean that 1 is in ``G``.

.. code:: python

    1 in G




.. parsed-literal::

    False



In order to see 1 in ``G``, we need to create an instance of it as
element in ``G``. And then, we can operate with it.

.. code:: python

    one=G(1)
    one*one




.. parsed-literal::

    2



As in this case, ``G`` is abelian, we can even perform the last
operation by using ``+``.

.. code:: python

    one+one




.. parsed-literal::

    2



Also, in this case powers become multiples.

.. code:: python

    one**3==3*one




.. parsed-literal::

    True



The Cayley table of ``G`` can be calculated as follows (multiplicative
table).

.. code:: python

    G.table()



.. raw:: html

    <head><style>
    table, th, td {border: 1px solid black;
     border-collapse: collapse;}
     th, td {padding: 15px;}</style></head>e = 0 &nbsp; 
     a = 1 &nbsp; 
     b = 2 &nbsp; 
     c = 3 &nbsp; 
     d = 4 &nbsp; 
    <p/>
     <table>
     <tr> <td bgcolor='White'> * </td> <td bgcolor=Red>e</td> <td bgcolor=Yellow>a</td> <td bgcolor=Lime>b</td> <td bgcolor=Blue>c</td> <td bgcolor=Tan>d</td> </tr>
    <tr> <td bgcolor=Red> e  </td> <td bgcolor=Red>e</td>  <td bgcolor=Yellow>a</td>  <td bgcolor=Lime>b</td>  <td bgcolor=Blue>c</td>  <td bgcolor=Tan>d</td></tr>
     <tr> <td bgcolor=Yellow> a  </td> <td bgcolor=Yellow>a</td>  <td bgcolor=Lime>b</td>  <td bgcolor=Blue>c</td>  <td bgcolor=Tan>d</td>  <td bgcolor=Red>e</td></tr>
     <tr> <td bgcolor=Lime> b  </td> <td bgcolor=Lime>b</td>  <td bgcolor=Blue>c</td>  <td bgcolor=Tan>d</td>  <td bgcolor=Red>e</td>  <td bgcolor=Yellow>a</td></tr>
     <tr> <td bgcolor=Blue> c  </td> <td bgcolor=Blue>c</td>  <td bgcolor=Tan>d</td>  <td bgcolor=Red>e</td>  <td bgcolor=Yellow>a</td>  <td bgcolor=Lime>b</td></tr>
     <tr> <td bgcolor=Tan> d  </td> <td bgcolor=Tan>d</td>  <td bgcolor=Red>e</td>  <td bgcolor=Yellow>a</td>  <td bgcolor=Lime>b</td>  <td bgcolor=Blue>c</td></tr>
     </table>


.. code:: python

    Set([i*one for i in range(10)])




.. parsed-literal::

    frozenset({1, 3, 2, 4, 0})



We can indeed do this last operation by considering the group spanned by
``one``; which is this case is ``G`` itself.

.. code:: python

    H=G.generate([one])
    H==G




.. parsed-literal::

    True



This means that this group is *cyclic*.

.. code:: python

    G.is_cyclic()




.. parsed-literal::

    True



The inverse of an element can be compute in several ways.

.. code:: python

    [G.inverse(one), one**-1]




.. parsed-literal::

    [4, 4]



We can compute the lattice of subgroups of ``G``.

.. code:: python

    subgs=G.subgroups()

.. code:: python

    [list(i) for i in subgs]




.. parsed-literal::

    [[0], [0, 1, 2, 3, 4]]



Since ``G`` is abelian, all its subgroups are normal.

.. code:: python

    all(H.is_normal_subgroup(G) for H in subgs)




.. parsed-literal::

    True



Indeed groups as ``G`` are quite common, this is why we dedided to write
an specific function to define them: ``CyclicGroup``. We will talk later
more about it.

The function ``CyclicGroup(n)`` returns (as defaul) the group
:math:`(\mathbb{Z}_n,+)`.

.. code:: python

    G.is_isomorphic(CyclicGroup(5))




.. parsed-literal::

    True



 Cartesian product and quotients
--------------------------------

A way to obtain groups from others is by computing cartesian products,
or quotients by normal subgroups.

Let us, for instance, compute ``G^2``

.. code:: python

    G2=G.cartesian(G)

The elements of ``G2`` are tuples. We can as above, instanciate one of
its elements.

.. code:: python

    one2=G2((1,1))

We can define the cyclic group generated by ``one2``, and check that
indeed is a subgroup of ``G2``.

.. code:: python

    H=G2.generate([one2])
    H<=G2




.. parsed-literal::

    True



Contrary to what happened above, in this case ``H`` is not ``G2``
itself; this is due to the fact that ``G2`` is no longer cyclic. Let us
compute a system of generators of ``G2``.

.. code:: python

    H==G2




.. parsed-literal::

    False



.. code:: python

    G2.is_cyclic()




.. parsed-literal::

    False



.. code:: python

    G2.generators()




.. parsed-literal::

    [(1, 3), (1, 2)]



We already know that every subgroup of an abelian group is normal, and
so we can compute the quotient of ``G2`` by ``H``.

.. code:: python

    G2/H




.. parsed-literal::

    Group with 5 elements



Its elements are congruency classes, and this is why when listing them,
we get a lists of sets.

.. code:: python

    Q=G2/H
    list(Q)




.. parsed-literal::

    [Set([(2, 2), (4, 4), (3, 3), (0, 0), (1, 1)]),
     Set([(3, 0), (1, 3), (4, 1), (2, 4), (0, 2)]),
     Set([(4, 3), (3, 2), (1, 0), (2, 1), (0, 4)]),
     Set([(4, 2), (0, 3), (3, 1), (1, 4), (2, 0)]),
     Set([(0, 1), (3, 4), (1, 2), (2, 3), (4, 0)])]



.. code:: python

    Q.is_abelian()




.. parsed-literal::

    True



.. code:: python

    Q.is_cyclic()




.. parsed-literal::

    True



.. code:: python

    [list(J) for J in G2.subgroups()]




.. parsed-literal::

    [[(0, 0), (3, 0), (2, 0), (1, 0), (4, 0)],
     [(0, 0), (2, 3), (3, 2), (4, 1), (1, 4)],
     [(0, 0), (0, 1), (0, 3), (0, 2), (0, 4)],
     [(0, 0)],
     [(0, 0),
      (1, 3),
      (3, 0),
      (2, 1),
      (0, 3),
      (4, 0),
      (1, 2),
      (3, 3),
      (4, 4),
      (2, 2),
      (4, 1),
      (1, 1),
      (3, 2),
      (0, 4),
      (1, 4),
      (2, 3),
      (4, 2),
      (1, 0),
      (0, 1),
      (3, 1),
      (0, 2),
      (2, 0),
      (4, 3),
      (3, 4),
      (2, 4)],
     [(0, 0), (4, 2), (1, 3), (3, 4), (2, 1)],
     [(0, 0), (2, 2), (1, 1), (4, 4), (3, 3)],
     [(0, 0), (1, 2), (3, 1), (2, 4), (4, 3)]]



 Permutations
-------------

Permutations are a fundamental tool for the study of groups. Indeed
permutations (bijective maps) of the set :math:`\{1,\ldots,n\}` under
composition are a group that is not abelian for :math:`n\ge 3`.

We have included a bunch of ways to define a permuation with the class
``permutation``.

-  ``permutation(list of integers)`` creates a permutation in which the
   :math:`i` goes to the :math:`i`\ th elmeent in the given list of
   integers.

-  ``permutation(sequence of integers)`` does the same as above, by
   considering the sequence as a list.

-  ``permutation(sequence of tuples)`` creates a permutation that is the
   product of the given tuples, by considering the tuples as cycles.

-  ``permutation(list of tuples)`` does the same as in the preceding
   case.

.. code:: python

    permutation(2,3,1,4)==permutation([2,3,1,4])




.. parsed-literal::

    True



.. code:: python

    permutation((1,2),(3,4))==permutation([(1,2),(3,4)])




.. parsed-literal::

    True



Composition of permutations is performed by using the ``*`` operator;
powers with ``**``.

.. code:: python

    p=permutation((1,2),(3,4))
    p*p




.. parsed-literal::

    ( )



You may gues from the above output that we are displaying the identity
map just by ``( )``. Permutations are displayed as a product of disjoint
cycles, and printed both in matrix representation and as a product of
disjoint cycles.

.. code:: python

    p




.. parsed-literal::

     (1, 2)(3, 4)



.. code:: python

    print(p)


.. parsed-literal::

    [2, 1, 4, 3] =  (1, 2)(3, 4)


.. code:: python

    p**-1==p




.. parsed-literal::

    True



The order of a permutation is computed as follows.

.. code:: python

    p.order()




.. parsed-literal::

    2



Also we can compute its sign, inversions and decomposition into disjoint
cycles.

.. code:: python

    p.sign()




.. parsed-literal::

    1



.. code:: python

    p.inversions()




.. parsed-literal::

    [(1, 2), (3, 4)]



.. code:: python

    p.disjoint_cycles()




.. parsed-literal::

    [(1, 2), (3, 4)]



 Groups of permutations
-----------------------

As we mentioned above, permutations of :math:`\{1,\ldots, n\}` with
composition as binary operation are a group, which is known as the
symmetric group and it is denoted by :math:`S_n`. We have a function to
created groups of permutations.

.. code:: python

    S3=SymmetricGroup(3)
    list(S3)




.. parsed-literal::

    [( ),  (2, 3),  (1, 3),  (1, 2),  (1, 3, 2),  (1, 2, 3)]



.. code:: python

    p=S3(permutation(3,2,1))
    q=S3(permutation(2,1,3))

.. code:: python

    H=S3.generate([p,q])

.. code:: python

    H.group_elems




.. parsed-literal::

    frozenset({( ),  (1, 3),  (2, 3),  (1, 3, 2),  (1, 2),  (1, 2, 3)})



An important subgroup of the symmetric group :math:`S_n` is the group of
all even (sign=1) permutations, which is known as the alternating group
and denoted by :math:`A_n`. It is well known that :math:`A_n` is a
normal subgroup of :math:`S_n`.

.. code:: python

    A3=AlternatingGroup(3)
    list(S3/A3)




.. parsed-literal::

    [Set([ (1, 2, 3),  (1, 3, 2), ( )]), Set([ (2, 3),  (1, 2),  (1, 3)])]



And in this way we are listing odd and even permutations in separate
sets.

The symmetric group :math:`S_n` has always a "copy" of
``CyclicGroup(n)``, which is the subgroup of :math:`S_n` spanned by the
cycle :math:`(1\ldots n)`. We can construct it as follows.

.. code:: python

    C3=CyclicGroup(3,"permutations")
    list(C3)




.. parsed-literal::

    [( ),  (1, 2, 3),  (1, 3, 2)]



.. code:: python

    Z3=CyclicGroup(3)
    list(C3)




.. parsed-literal::

    [( ),  (1, 2, 3),  (1, 3, 2)]



.. code:: python

    C3.is_isomorphic(Z3)




.. parsed-literal::

    True



Another important subgroup of the :math:`S_n` is the dihedral group of
movements that leave invariant an :math:`n`-gon centered in the origin.
This group can be represented either by permutations or by symmetries
and rotations.

.. code:: python

    D4=DihedralGroup(4)
    D4.table()



.. raw:: html

    <head><style>
    table, th, td {border: 1px solid black;
     border-collapse: collapse;}
     th, td {padding: 15px;}</style></head>e = R0 &nbsp; 
     a = R1 &nbsp; 
     b = R2 &nbsp; 
     c = R3 &nbsp; 
     d = S3 &nbsp; 
     f = S2 &nbsp; 
     g = S1 &nbsp; 
     h = S0 &nbsp; 
    <p/>
     <table>
     <tr> <td bgcolor='White'> * </td> <td bgcolor=Red>e</td> <td bgcolor=Yellow>a</td> <td bgcolor=Lime>b</td> <td bgcolor=Blue>c</td> <td bgcolor=Tan>d</td> <td bgcolor=YellowGreen>f</td> <td bgcolor=Violet>g</td> <td bgcolor=SkyBlue>h</td> </tr>
    <tr> <td bgcolor=Red> e  </td> <td bgcolor=Red>e</td>  <td bgcolor=Yellow>a</td>  <td bgcolor=Lime>b</td>  <td bgcolor=Blue>c</td>  <td bgcolor=Tan>d</td>  <td bgcolor=YellowGreen>f</td>  <td bgcolor=Violet>g</td>  <td bgcolor=SkyBlue>h</td></tr>
     <tr> <td bgcolor=Yellow> a  </td> <td bgcolor=Yellow>a</td>  <td bgcolor=Lime>b</td>  <td bgcolor=Blue>c</td>  <td bgcolor=Red>e</td>  <td bgcolor=SkyBlue>h</td>  <td bgcolor=Tan>d</td>  <td bgcolor=YellowGreen>f</td>  <td bgcolor=Violet>g</td></tr>
     <tr> <td bgcolor=Lime> b  </td> <td bgcolor=Lime>b</td>  <td bgcolor=Blue>c</td>  <td bgcolor=Red>e</td>  <td bgcolor=Yellow>a</td>  <td bgcolor=Violet>g</td>  <td bgcolor=SkyBlue>h</td>  <td bgcolor=Tan>d</td>  <td bgcolor=YellowGreen>f</td></tr>
     <tr> <td bgcolor=Blue> c  </td> <td bgcolor=Blue>c</td>  <td bgcolor=Red>e</td>  <td bgcolor=Yellow>a</td>  <td bgcolor=Lime>b</td>  <td bgcolor=YellowGreen>f</td>  <td bgcolor=Violet>g</td>  <td bgcolor=SkyBlue>h</td>  <td bgcolor=Tan>d</td></tr>
     <tr> <td bgcolor=Tan> d  </td> <td bgcolor=Tan>d</td>  <td bgcolor=YellowGreen>f</td>  <td bgcolor=Violet>g</td>  <td bgcolor=SkyBlue>h</td>  <td bgcolor=Red>e</td>  <td bgcolor=Yellow>a</td>  <td bgcolor=Lime>b</td>  <td bgcolor=Blue>c</td></tr>
     <tr> <td bgcolor=YellowGreen> f  </td> <td bgcolor=YellowGreen>f</td>  <td bgcolor=Violet>g</td>  <td bgcolor=SkyBlue>h</td>  <td bgcolor=Tan>d</td>  <td bgcolor=Blue>c</td>  <td bgcolor=Red>e</td>  <td bgcolor=Yellow>a</td>  <td bgcolor=Lime>b</td></tr>
     <tr> <td bgcolor=Violet> g  </td> <td bgcolor=Violet>g</td>  <td bgcolor=SkyBlue>h</td>  <td bgcolor=Tan>d</td>  <td bgcolor=YellowGreen>f</td>  <td bgcolor=Lime>b</td>  <td bgcolor=Blue>c</td>  <td bgcolor=Red>e</td>  <td bgcolor=Yellow>a</td></tr>
     <tr> <td bgcolor=SkyBlue> h  </td> <td bgcolor=SkyBlue>h</td>  <td bgcolor=Tan>d</td>  <td bgcolor=YellowGreen>f</td>  <td bgcolor=Violet>g</td>  <td bgcolor=Yellow>a</td>  <td bgcolor=Lime>b</td>  <td bgcolor=Blue>c</td>  <td bgcolor=Red>e</td></tr>
     </table>


Product and intersection of subgroups
-------------------------------------

Product and intersection of subgroups of a group :math:`G` are again
subgroups of :math:`G`

.. code:: python

    Dp4=DihedralGroup(4,"permutations")
    list(Dp4)




.. parsed-literal::

    [( ),
      (1, 4, 3, 2),
      (1, 3)(2, 4),
      (2, 4),
      (1, 2, 3, 4),
      (1, 4)(2, 3),
      (1, 2)(3, 4),
      (1, 3)]



.. code:: python

    A4=AlternatingGroup(4)
    A4*Dp4




.. parsed-literal::

    Group with 24 elements



.. code:: python

    list(A4.intersection(Dp4))




.. parsed-literal::

    [( ),  (1, 4)(2, 3),  (1, 2)(3, 4),  (1, 3)(2, 4)]



We can for instance, illustrate the third isometry theorem:
:math:`KN/N\cong K/(K\cap N)`.

.. code:: python

    Q1=(A4*Dp4)/A4
    Q2=Dp4/(A4.intersection(Dp4))
    Q1.is_isomorphic(Q2)




.. parsed-literal::

    True



 Lateral classes, conjugacy clases and center
---------------------------------------------

Lateral classes are easy to construct; they are considered as sets.

.. code:: python

    S4=SymmetricGroup(4)
    p=S4(permutation([2,3,4,1]))
    p*A4




.. parsed-literal::

    { (1, 4, 3, 2),
      (1, 4, 2, 3),
      (1, 2, 3, 4),
      (2, 3),
      (2, 4),
      (1, 2, 4, 3),
      (3, 4),
      (1, 3, 4, 2),
      (1, 3, 2, 4),
      (1, 3),
      (1, 2),
      (1, 4)}



.. code:: python

    A4*p




.. parsed-literal::

    { (3, 4),
      (1, 3),
      (2, 4),
      (1, 4),
      (1, 3, 4, 2),
      (1, 4, 3, 2),
      (1, 3, 2, 4),
      (1, 2, 4, 3),
      (1, 2, 3, 4),
      (2, 3),
      (1, 4, 2, 3),
      (1, 2)}



The conjugacy class of an element and of a subgroup can be calculated as
follows.

.. code:: python

    p.conjugacy_class()




.. parsed-literal::

    frozenset({ (1, 2, 3, 4),
                (1, 3, 4, 2),
                (1, 4, 3, 2),
                (1, 3, 2, 4),
                (1, 2, 4, 3),
                (1, 4, 2, 3)})



.. code:: python

    A4.conjugacy_class()




.. parsed-literal::

    {frozenset({ (1, 3)(2, 4),
                 (2, 3, 4),
                 (1, 2, 4),
                 (1, 2, 3),
                 (1, 4, 3),
                 (1, 4, 2),
                 (1, 3, 4),
                 (1, 4)(2, 3),
                 (2, 4, 3),
                ( ),
                 (1, 2)(3, 4),
                 (1, 3, 2)})}



And also the set of all conjugacy classes.

.. code:: python

    S4.conjugacy_classes()




.. parsed-literal::

    {frozenset({ (1, 4, 3, 2),
                 (1, 3, 2, 4),
                 (1, 2, 3, 4),
                 (1, 3, 4, 2),
                 (1, 2, 4, 3),
                 (1, 4, 2, 3)}),
     frozenset({ (2, 4, 3),
                 (2, 3, 4),
                 (1, 3, 2),
                 (1, 4, 3),
                 (1, 2, 4),
                 (1, 4, 2),
                 (1, 3, 4),
                 (1, 2, 3)}),
     frozenset({ (1, 3)(2, 4),  (1, 2)(3, 4),  (1, 4)(2, 3)}),
     frozenset({ (2, 4),  (2, 3),  (1, 3),  (1, 4),  (3, 4),  (1, 2)})}



The normalizar of a subgroup can be computed with ``normalizer``.

.. code:: python

    A4.normalizer()




.. parsed-literal::

    Group with 24 elements



And the center with ``center``.

.. code:: python

    S4.center()




.. parsed-literal::

    Group with 1 elements



Quaternions and the Klein group
-------------------------------

.. code:: python

    Q2=QuaternionGroup()
    list(Q2)




.. parsed-literal::

    ['1', 'i', 'k', 'j', '-i', '-k', '-j', '-1']



.. code:: python

    Q2.center()




.. parsed-literal::

    Group with 2 elements



.. code:: python

    K=KleinGroup()

.. code:: python

    list(K)




.. parsed-literal::

    [(0, 0), (0, 1), (1, 0), (1, 1)]



.. code:: python

    list(KleinGroup("permutations"))




.. parsed-literal::

    [( ),  (1, 4)(2, 3),  (1, 3)(2, 4),  (1, 2)(3, 4)]



.. code:: python

    Q=Q2/Q2.center()

.. code:: python

    Q.is_cyclic()




.. parsed-literal::

    False



.. code:: python

    Q.is_isomorphic(K)




.. parsed-literal::

    True


